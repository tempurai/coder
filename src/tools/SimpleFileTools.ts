import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import * as util from 'util';
import { z } from 'zod';
import { tool } from 'ai';
import { ToolContext } from './base.js';
import { ToolOutputEvent } from '../events/EventTypes.js';

const execAsync = util.promisify(exec);

export const createWriteFileTool = (context: ToolContext) => tool({
    description: `Write content to a file or overwrite an existing file.
    This operation is direct and atomic. All changes should be made on a task branch.
    The Git workflow handles versioning, backups, and rollbacks automatically.`,
    inputSchema: z.object({
        filePath: z.string().describe('Path to the file to write'),
        content: z.string().describe('Content to write to the file')
    }),
    execute: async ({ filePath, content }) => {
        try {
            const absolutePath = path.resolve(filePath);
            const dir = path.dirname(absolutePath);

            if (!fs.existsSync(dir)) {
                context.eventEmitter.emit({
                    type: 'tool_output',
                    toolName: 'write_file',
                    content: `Creating directory: ${dir}`
                } as ToolOutputEvent);
                fs.mkdirSync(dir, { recursive: true });
            }

            await fs.promises.writeFile(absolutePath, content, 'utf-8');

            context.eventEmitter.emit({
                type: 'tool_output',
                toolName: 'write_file',
                content: `File written: ${filePath} (${content.length} characters)`
            } as ToolOutputEvent);

            return {
                success: true,
                filePath: absolutePath,
                size: content.length,
                message: `File '${filePath}' written successfully`
            };
        } catch (error) {
            return {
                success: false,
                filePath,
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }
});

export const createReadFileTool = (context: ToolContext) => tool({
    description: 'Read the contents of a file and return as text',
    inputSchema: z.object({
        filePath: z.string().describe('Path to the file to read'),
    }),
    execute: async ({ filePath }) => {
        try {
            const absolutePath = path.resolve(filePath);
            if (!fs.existsSync(absolutePath)) {
                return {
                    success: false,
                    filePath,
                    error: `File not found: ${filePath}`
                };
            }

            const content = await fs.promises.readFile(absolutePath, 'utf-8');
            const stats = await fs.promises.stat(absolutePath);

            context.eventEmitter.emit({
                type: 'tool_output',
                toolName: 'read_file',
                content: `Read file: ${filePath} (${content.length} characters)`
            } as ToolOutputEvent);

            return {
                success: true,
                filePath: absolutePath,
                content: content,
                size: content.length,
                lastModified: stats.mtime.toISOString(),
                message: `File '${filePath}' read successfully`
            };
        } catch (error) {
            return {
                success: false,
                filePath,
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }
});

export const createApplyPatchTool = (context: ToolContext) => tool({
    description: `Apply a unified diff patch to a file. 
    The LLM should generate the patch in standard unified diff format.
    This tool will apply the patch using the system patch command or fallback to manual application.`,
    inputSchema: z.object({
        filePath: z.string().describe('Path to the file to patch'),
        patchContent: z.string().describe('Unified diff content generated by LLM'),
        backup: z.boolean().default(true).describe('Create backup before applying patch')
    }),
    execute: async ({ filePath, patchContent, backup }) => {
        try {
            const absolutePath = path.resolve(filePath);
            if (!fs.existsSync(absolutePath)) {
                return {
                    success: false,
                    filePath,
                    error: `File not found: ${filePath}`
                };
            }

            context.eventEmitter.emit({
                type: 'tool_output',
                toolName: 'apply_patch',
                content: `Applying patch to: ${filePath}`
            } as ToolOutputEvent);

            const tempPatchFile = path.join(path.dirname(absolutePath), `.patch_${Date.now()}.tmp`);
            await fs.promises.writeFile(tempPatchFile, patchContent, 'utf-8');

            try {
                const patchCmd = `patch "${absolutePath}" < "${tempPatchFile}"`;
                if (backup) {
                    const backupPath = `${absolutePath}.backup.${Date.now()}`;
                    await fs.promises.copyFile(absolutePath, backupPath);
                    context.eventEmitter.emit({
                        type: 'tool_output',
                        toolName: 'apply_patch',
                        content: `Backup created: ${backupPath}`
                    } as ToolOutputEvent);
                }

                const { stdout, stderr } = await execAsync(patchCmd);
                await fs.promises.unlink(tempPatchFile);

                context.eventEmitter.emit({
                    type: 'tool_output',
                    toolName: 'apply_patch',
                    content: `Patch applied successfully\n${stdout}`
                } as ToolOutputEvent);

                return {
                    success: true,
                    filePath: absolutePath,
                    stdout: stdout.trim(),
                    stderr: stderr.trim(),
                    message: `Patch applied successfully'`,
                };
            } catch (patchError) {
                context.eventEmitter.emit({
                    type: 'tool_output',
                    toolName: 'apply_patch',
                    content: 'System patch failed, attempting manual application...'
                } as ToolOutputEvent);

                const result = await applyPatchManually(absolutePath, patchContent, backup, context);
                await fs.promises.unlink(tempPatchFile);
                return result;
            }
        } catch (error) {
            return {
                success: false,
                filePath,
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }
});

async function applyPatchManually(filePath: string, patchContent: string, backup: boolean, context: ToolContext) {
    function detectNewline(text: string): '\n' | '\r\n' {
        const idx = text.indexOf('\r\n');
        return idx !== -1 ? '\r\n' : '\n';
    }

    interface Change { type: 'add' | 'delete' | 'context'; content: string }
    interface Hunk {
        oldStart: number;
        oldCount: number;
        newStart: number;
        newCount: number;
        changes: Change[];
    }

    const originalContent = await fs.promises.readFile(filePath, 'utf-8');
    const eol = detectNewline(originalContent);
    const originalLines = originalContent.split(/\r?\n/);
    const patchLines = patchContent.split(/\r?\n/);

    const hunks: Hunk[] = [];
    let currentHunk: Hunk | null = null;

    for (const line of patchLines) {
        if (line.startsWith('@@')) {
            const match = line.match(/@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@/);
            if (match) {
                currentHunk = {
                    oldStart: parseInt(match[1], 10) - 1,
                    oldCount: parseInt(match[2] || '1', 10),
                    newStart: parseInt(match[3], 10) - 1,
                    newCount: parseInt(match[4] || '1', 10),
                    changes: [],
                };
                hunks.push(currentHunk);
            } else {
                currentHunk = null;
            }
        } else if (currentHunk && (line.startsWith('+') || line.startsWith('-') || line.startsWith(' '))) {
            currentHunk.changes.push({
                type: line[0] === '+' ? 'add' : line[0] === '-' ? 'delete' : 'context',
                content: line.substring(1),
            });
        }
    }

    let modifiedLines = [...originalLines];
    let lineOffset = 0;

    for (const hunk of hunks) {
        let pos = hunk.oldStart + lineOffset;
        for (const change of hunk.changes) {
            if (change.type === 'context') {
                if (modifiedLines[pos] !== change.content) {
                    throw new Error(`Context mismatch near line ${pos + 1}: expected "${change.content}" but got "${modifiedLines[pos]}"`);
                }
                pos++;
            } else if (change.type === 'delete') {
                if (modifiedLines[pos] !== change.content) {
                    throw new Error(`Delete mismatch near line ${pos + 1}: expected "${change.content}" but got "${modifiedLines[pos]}"`);
                }
                modifiedLines.splice(pos, 1);
                lineOffset--;
            } else if (change.type === 'add') {
                modifiedLines.splice(pos, 0, change.content);
                lineOffset++;
                pos++;
            }
        }
    }

    if (backup) {
        const backupPath = `${filePath}.backup.${Date.now()}`;
        await fs.promises.copyFile(filePath, backupPath);
    }

    await fs.promises.writeFile(filePath, modifiedLines.join(eol), 'utf-8');

    context.eventEmitter.emit({
        type: 'tool_output',
        toolName: 'apply_patch',
        content: `Patch applied successfully (manual parser) - ${hunks.length} changes applied`
    } as ToolOutputEvent);

    return {
        success: true,
        filePath,
        message: 'Patch applied successfully (manual parser)',
        changesApplied: hunks.length,
    };
}

export const createFindFilesTool = (context: ToolContext) => tool({
    description: 'Search for files by pattern in the current directory',
    inputSchema: z.object({
        pattern: z.string().describe('File name pattern to search for'),
    }),
    execute: async ({ pattern }) => {
        try {
            const { stdout } = await execAsync(`find . -name "*${pattern}*" -type f`);
            const files = stdout.trim().split('\n').filter(f => f.length > 0);

            context.eventEmitter.emit({
                type: 'tool_output',
                toolName: 'find_files',
                content: `Found ${files.length} files matching '${pattern}':\n${files.join('\n')}`
            } as ToolOutputEvent);

            return {
                success: true,
                files,
                count: files.length,
                pattern,
                message: `Found ${files.length} files matching '${pattern}'`
            };
        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
                files: [],
                count: 0,
                pattern
            };
        }
    },
});

export const createSearchInFilesTool = (context: ToolContext) => tool({
    description: 'Search for keywords in TypeScript and JavaScript files',
    inputSchema: z.object({
        keyword: z.string().describe('Keyword to search for in files'),
        filePattern: z.string().default('*.{ts,js,tsx,jsx}').describe('File pattern to search in')
    }),
    execute: async ({ keyword, filePattern }) => {
        try {
            const { stdout } = await execAsync(`grep -r -n "${keyword}" --include="${filePattern}" .`);
            const matches = stdout.trim().split('\n').filter(m => m.length > 0);
            const parsedMatches = matches.map(match => {
                const [filePath, lineNumber, ...contentParts] = match.split(':');
                return {
                    file: filePath,
                    line: parseInt(lineNumber),
                    content: contentParts.join(':').trim()
                };
            });

            const displayContent = parsedMatches.slice(0, 10).map(match =>
                `${match.file}:${match.line}: ${match.content}`
            ).join('\n') + (matches.length > 10 ? `\n... and ${matches.length - 10} more matches` : '');

            context.eventEmitter.emit({
                type: 'tool_output',
                toolName: 'search_in_files',
                content: `Found ${matches.length} matches for '${keyword}' in ${filePattern}:\n${displayContent}`
            } as ToolOutputEvent);

            return {
                success: true,
                matches: parsedMatches,
                count: matches.length,
                keyword,
                filePattern,
                message: `Found ${matches.length} matches for '${keyword}'`
            };
        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
                matches: [],
                count: 0,
                keyword,
                filePattern
            };
        }
    },
});